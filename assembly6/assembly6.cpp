#include <stdio.h>
#include <string.h>

int main() {
    char source[64] = "mmmmmm nnnnnn oooo pppp qqq rr";
    char output[256] = "";
    static char freq[256];

    _asm {
        lea esi, source; Указатель на начало исходной строки
        lea edi, output; Указатель на начало выходной строки

        Start :
    SkipSpaces:
        mov al, [esi]; Загружаем текущий символ
            cmp al, 0; Проверяем, достигнут ли конец строки
            je End; Если конец строки, завершить
            cmp al, ' '; Проверяем, является ли символ пробелом
            jne StartWord; Если не пробел, перейти к началу слова
            inc esi; Сдвигаем указатель источника на следующий символ
            jmp SkipSpaces; Пропускаем пробелы

            StartWord :
        lea edi, freq; Указатель на массив `freq`
            mov ecx, 256; Длина массива
            mov eax, 0; Значение для заполнения
            rep stosb; Обнуляем массив `freq`

            mov edx, esi; Сохраняем начало текущего слова в EDX

            ProcessWord :
        mov al, [esi]; Загружаем текущий символ
            cmp al, 0; Проверяем конец строки
            je CheckFreq; Если конец строки, проверяем частоты
            cmp al, ' '; Проверяем пробел(конец слова)
            je CheckFreq; Если пробел, переходим к частотам

            movzx ebx, al; Загружаем символ как индекс
            lea ecx, freq; Адрес массива `freq`
            inc byte ptr[ecx + ebx]; Увеличиваем счётчик символа
            inc esi; Переходим к следующему символу
            jmp ProcessWord; Продолжаем обработку слова

            CheckFreq :
        lea esi, freq; Указатель на массив частот
            mov ecx, 256; Длина массива

            CheckFreqLoop :
        lodsb; Загружаем следующий байт массива `freq`
            cmp al, 3; Проверяем, больше ли частота 3
            jg HasRepeats; Если больше, переходим к копированию слова
            loop CheckFreqLoop; Переходим к следующему элементу массива
            mov esi, edx; Возвращаем указатель на начало слова
            jmp SkipWord; Пропускаем слово, так как оно не подходит

            HasRepeats :
        mov esi, edx; Восстанавливаем указатель на начало слова

            CopyWord :
        mov al, [esi]; Загружаем текущий символ слова
            cmp al, 0; Проверяем конец строки
            je EndCopy; Если конец строки, завершить копирование
            cmp al, ' '; Проверяем пробел(конец слова)
            je EndCopy; Если пробел, завершить копирование
            mov[edi], al; Копируем символ в выходную строку
            inc esi; Следующий символ источника
            inc edi; Следующая позиция назначения
            jmp CopyWord; Продолжаем копирование слова

            EndCopy :
        mov byte ptr[edi], ' '; Добавляем пробел в выходную строку
            inc edi; Сдвигаем указатель назначения
            mov esi, edx; Восстанавливаем указатель на начало слова

            SkipWord :
        mov al, [esi]; Загружаем текущий символ
            cmp al, 0; Проверяем конец строки
            je End; Если конец строки, завершить
            cmp al, ' '; Проверяем пробел(конец слова)
            je Continue; Если пробел, переходим к следующему слову
            inc esi; Переходим к следующему символу
            jmp SkipWord; Продолжаем пропуск слова

            Continue :
        inc esi; Сдвигаем указатель на следующий символ
            jmp Start; Переходим к началу обработки

            End :
        mov byte ptr[edi], 0; Добавляем нуль - терминатор в конец выходной строки
    }

    printf("%s\n", output);
    return 0;
}
